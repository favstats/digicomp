---
title: "{{< iconify ph info >}} About"
format: html
---

```{r}
#| include: false
library(dashboardr)
```

This dashboard aggregates and visualizes data

## Dashboard Creators

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(htmltools)
library(dashboardr)

mario_card <- card(
  content = "Mario il Gatto is a data scientist who believes that every dataset has a soul and that R is the language of the gods. He spends his days making beautiful visualizations and his nights dreaming of perfectly normalized databases.",
  title = "Mario il Gatto",
  image = "https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?w=300&h=200&fit=crop",
  image_alt = "Photo of a majestic orange cat",
  footer = "Website: mario-il-gatto.data",
  class = "mb-3"
)

giuseppe_card <- card(
  content = "Giuseppe il Cane is a machine learning engineer who thinks that neural networks are just very complicated dogs. He's convinced that every algorithm needs a good walk and that overfitting is just a sign of too much enthusiasm.",
  title = "Giuseppe il Cane",
  image = "https://images.unsplash.com/photo-1552053831-71594a27632d?w=300&h=200&fit=crop",
  image_alt = "Photo of a happy golden retriever",
  footer = "Website: giuseppe-il-cane.ai",
  class = "mb-3"
)

# Display cards in a row using the card_row function
card_row(mario_card, giuseppe_card)
```
## More about Dashboardr
Dashboardr is an R package with a clear vision: to make it intuitive for everyone to create beautiful dashboards.
The package is especially useful when time is limited. The iterative piping logic means that it is very quick to add new pages
and plots, even when the user is inexperienced with programming.
In a variety of contexts, this means that you can get quick, beautiful insights to present findings to wider audiences.


```{=html}

<style>
/* Chart Lazy Loading Styles */
.chart-lazy {
  position: relative;
  min-height: 400px;
  margin: 1rem 0;
}

.chart-skeleton {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 1rem;
  transition: opacity 0.3s ease;
}

.chart-spinner {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.chart-loading-text {
  font-size: 0.9rem;
  font-weight: 500;
  letter-spacing: 0.5px;
}

/* Theme: Light */
.chart-skeleton.theme-light {
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid rgba(0, 0, 0, 0.05);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.chart-skeleton.theme-light .chart-spinner {
  border: 3px solid rgba(148, 163, 184, 0.2);
  border-top-color: rgba(15, 23, 42, 0.8);
}

.chart-skeleton.theme-light .chart-loading-text {
  color: rgba(15, 23, 42, 0.7);
}

/* Theme: Glass */
.chart-skeleton.theme-glass {
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.4);
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
}

.chart-skeleton.theme-glass .chart-spinner {
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-top-color: rgba(15, 23, 42, 0.7);
}

.chart-skeleton.theme-glass .chart-loading-text {
  color: rgba(15, 23, 42, 0.8);
}

/* Theme: Dark */
.chart-skeleton.theme-dark {
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.chart-skeleton.theme-dark .chart-spinner {
  border: 3px solid rgba(148, 163, 184, 0.3);
  border-top-color: rgba(255, 255, 255, 0.9);
}

.chart-skeleton.theme-dark .chart-loading-text {
  color: rgba(255, 255, 255, 0.9);
}

/* Theme: Accent */
.chart-skeleton.theme-accent {
  background: rgba(255, 255, 255, 0.98);
  border: 1px solid rgba(59, 130, 246, 0.15);
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(59, 130, 246, 0.15);
}

.chart-skeleton.theme-accent .chart-spinner {
  border: 3px solid rgba(59, 130, 246, 0.2);
  border-top-color: rgba(59, 130, 246, 0.9);
}

.chart-skeleton.theme-accent .chart-loading-text {
  color: rgba(15, 23, 42, 0.8);
}
</style>

<script>
// Chart Lazy Loading System
(function() {
  const THEME = 'light';
  const DEBUG = true;
  
  // Track which charts have been initialized
  const initializedCharts = new Set();
  
  // Queue of charts waiting to be initialized
  const chartQueue = [];
  let isProcessingQueue = false;
  
  // Performance tracking
  let totalChartsLoaded = 0;
  let totalLoadTime = 0;
  const chartTimings = [];
  
  // Create skeleton loader dynamically
  function createSkeleton(container) {
    const skeleton = document.createElement('div');
    skeleton.className = 'chart-skeleton theme-' + THEME;
    skeleton.innerHTML = `
      <div class="chart-spinner"></div>
      <div class="chart-loading-text">Loading visualization...</div>
    `;
    container.appendChild(skeleton);
    return skeleton;
  }
  
  // Initialize a single chart
  function initChart(container) {
    const chartId = container.id;
    if (initializedCharts.has(chartId)) return;
    
    const startTime = DEBUG ? performance.now() : 0;
    
    initializedCharts.add(chartId);
    container.dataset.loaded = 'true';
    
    // Remove skeleton loader
    const skeleton = container.querySelector('.chart-skeleton');
    if (skeleton) {
      skeleton.style.opacity = '0';
      setTimeout(() => skeleton.remove(), 300);
    }
    
    // Trigger Highcharts reflow if present
    setTimeout(() => {
      if (window.Highcharts) {
        Highcharts.charts.forEach(chart => {
          if (chart && chart.reflow) chart.reflow();
        });
      }
      
      // Debug logging
      if (DEBUG) {
        const loadTime = performance.now() - startTime;
        totalChartsLoaded++;
        totalLoadTime += loadTime;
        chartTimings.push({ id: chartId, time: loadTime });
        
        console.log(`ðŸ“Š Chart loaded: ${chartId} (${loadTime.toFixed(2)}ms)`);
        console.log(`   Total: ${totalChartsLoaded} charts, Avg: ${(totalLoadTime/totalChartsLoaded).toFixed(2)}ms`);
      }
    }, 50);
  }
  
  // Process chart queue in batches
  function processQueue() {
    if (isProcessingQueue || chartQueue.length === 0) return;
    
    isProcessingQueue = true;
    const batchSize = 3;
    const batch = chartQueue.splice(0, batchSize);
    
    if (DEBUG) {
      console.log(`âš¡ Processing batch of ${batch.length} charts (${chartQueue.length} remaining)`);
    }
    
    batch.forEach(container => initChart(container));
    
    if (chartQueue.length > 0) {
      requestIdleCallback(() => {
        isProcessingQueue = false;
        processQueue();
      }, { timeout: 2000 });
    } else {
      isProcessingQueue = false;
      
      if (DEBUG && totalChartsLoaded > 0) {
        console.log(`âœ… All charts loaded! Summary:`);
        console.log(`   Total charts: ${totalChartsLoaded}`);
        console.log(`   Total time: ${totalLoadTime.toFixed(2)}ms`);
        console.log(`   Average time per chart: ${(totalLoadTime/totalChartsLoaded).toFixed(2)}ms`);
        console.log(`   Slowest chart: ${Math.max(...chartTimings.map(t => t.time)).toFixed(2)}ms`);
        console.log(`   Fastest chart: ${Math.min(...chartTimings.map(t => t.time)).toFixed(2)}ms`);
      }
    }
  }
  
  // Intersection Observer for scroll-based lazy loading
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && entry.target.dataset.loaded === 'false') {
        chartQueue.push(entry.target);
        observer.unobserve(entry.target);
        processQueue();
      }
    });
  }, { rootMargin: '300px' });
  
  // Initialize observers when DOM is ready
  function initLazyLoading() {
    document.querySelectorAll('.chart-lazy[data-loaded="false"]').forEach(container => {
      // Create skeleton for each lazy chart
      createSkeleton(container);
      // Start observing
      observer.observe(container);
    });
  }
  
  // Tab-aware rendering: load charts when tab becomes visible
  function initTabAwareLoading() {
    document.querySelectorAll('.panel-tabset').forEach(tabset => {
      const tabs = tabset.querySelectorAll('[role="tab"]');
      
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          setTimeout(() => {
            const targetId = this.getAttribute('aria-controls');
            if (!targetId) return;
            
            const targetPanel = document.getElementById(targetId);
            if (!targetPanel) return;
            
            // Initialize any lazy charts in this tab
            const lazyCharts = targetPanel.querySelectorAll('.chart-lazy[data-loaded="false"]');
            lazyCharts.forEach(chart => {
              chartQueue.push(chart);
              observer.unobserve(chart);
            });
            processQueue();
          }, 50);
        });
      });
    });
  }
  
  // Start lazy loading when document is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      initLazyLoading();
      initTabAwareLoading();
    });
  } else {
    initLazyLoading();
    initTabAwareLoading();
  }
})();
</script>

```

